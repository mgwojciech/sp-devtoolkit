{"version":3,"sources":["APIClient.tsx","Utils/CurrentTabWebClient.ts","Utils/DevToolsCurrentTabWebClient.ts","Utils/CurrentTabPageContextProvider.ts","Components/PageContextInfoComponent.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["APIClient","props","state","Response","WebUrl","EndpointUrl","Method","Digests","UpdateWebUrl","bind","HandleClick","UpdateEndpointUrl","UpdateRequestBody","UpdateMethod","self","this","contextUrl","siteDigest","filter","d","Site","Promise","resolve","Digest","WebClient","CallWebService","method","headers","accept","then","result","push","FormDigestValue","forceUpdate","url","GetFormDigest","digest","body","RequestBody","JSON","stringify","parse","setState","event","newValue","option","index","text","selectedItem","TextField","label","onChange","value","Dropdown","placeholder","selectedKey","options","key","styles","dropdown","width","multiline","autoAdjustHeight","PrimaryButton","onClick","allowDisabledFocus","Component","CurrentTabWebClient","requestProperties","requestPropsSerialized","error","chrome","tabs","getSelected","tab","executeScript","id","code","runtime","onMessage","addListener","listener","removeListener","DevToolsCurrentTabWebClient","devtools","inspectedWindow","eval","CurrentTabPageContextProvider","spPageContextInfo","PageContextInfoComponent","PageContextInfoProvider","GetPageContextInfo","info","Info","App","webClient","pcProvider","className","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.a232d981.chunk.js","sourcesContent":["import React, { Component } from 'react';\r\nimport { TextField } from 'office-ui-fabric-react/lib/TextField';\r\nimport { Dropdown, IDropdownOption } from 'office-ui-fabric-react/lib/Dropdown';\r\nimport { PrimaryButton } from 'office-ui-fabric-react/lib/Button'\r\nimport 'office-ui-fabric-react/dist/sass/_References.scss'\r\nimport { IWebClient } from './Utils/IWebClient';\r\n\r\nexport interface APIClientProps {\r\n    WebClient: IWebClient\r\n}\r\nexport interface APIClientState {\r\n    WebUrl: string,\r\n    EndpointUrl: string,\r\n    Method: string,\r\n    Response: any,\r\n    RequestBody?: string,\r\n    Digests: { Site: string, Digest: string }[]\r\n}\r\n\r\nexport class APIClient extends Component<APIClientProps, APIClientState> {\r\n\r\n    constructor(props: APIClientProps, state: APIClientState) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            Response: \"\",\r\n            WebUrl: \"\",\r\n            EndpointUrl: \"/_api/web\",\r\n            Method: \"GET\",\r\n            Digests: []\r\n        }\r\n        this.UpdateWebUrl = this.UpdateWebUrl.bind(this);\r\n        this.HandleClick = this.HandleClick.bind(this);\r\n        this.UpdateEndpointUrl = this.UpdateEndpointUrl.bind(this);\r\n        this.UpdateRequestBody = this.UpdateRequestBody.bind(this);\r\n        this.UpdateMethod = this.UpdateMethod.bind(this);\r\n    }\r\n\r\n    private GetFormDigest(): Promise<string> {\r\n        let self = this;\r\n        let contextUrl: string = self.state.WebUrl + \"/_api/contextinfo\";\r\n\r\n        let siteDigest = self.state.Digests.filter(d => {\r\n            return d.Site === self.state.WebUrl\r\n        })[0];\r\n        if (siteDigest)\r\n            return new Promise<string>(resolve => {\r\n                resolve(siteDigest.Digest);\r\n            });\r\n\r\n        return self.props.WebClient.CallWebService(contextUrl, {\r\n            method: \"POST\",\r\n            headers: {accept: \"application/json\" },\r\n        }).then((result: any) => {\r\n            self.state.Digests.push({\r\n                Site: self.state.WebUrl,\r\n                Digest: result.FormDigestValue\r\n            })\r\n            self.forceUpdate();\r\n            return result.FormDigestValue;\r\n        })\r\n    }\r\n\r\n    private HandleClick() {\r\n        var url = (this.state.WebUrl || \"\") + this.state.EndpointUrl;\r\n        let self = this;\r\n        if (self.state.Method != \"GET\") {\r\n            self.GetFormDigest().then(digest=>{\r\n            self.props.WebClient.CallWebService(url, {\r\n                headers: {\r\n                    accept: \"application/json\",\r\n                    \"X-RequestDigest\": digest, \r\n                    \"Content-Type\": \"application/json\",\r\n                    \"IF-MATCH\": \"*\",\r\n                    \"X-HTTP-Method\":self.state.Method\r\n                },\r\n                method: \"POST\",\r\n                body: self.state.RequestBody ? JSON.stringify(JSON.parse(self.state.RequestBody)) : null\r\n            }).then(result => {\r\n                self.setState({ ...self.state, Response: JSON.stringify(result, null, 4) })\r\n            });\r\n            })\r\n        }\r\n\r\n        else {\r\n            self.props.WebClient.CallWebService(url, {\r\n                headers: {accept: \"application/json\"},\r\n                method: self.state.Method\r\n            }).then(result => {\r\n                self.setState({ ...self.state, Response: JSON.stringify(result, null, 4) })\r\n            });\r\n        }\r\n    }\r\n\r\n    private UpdateWebUrl(event: React.FormEvent<HTMLInputElement | HTMLTextAreaElement>, newValue?: string) {\r\n        if (newValue)\r\n            this.setState({ ...this.state, WebUrl: newValue })\r\n    }\r\n    private UpdateEndpointUrl(event: React.FormEvent<HTMLInputElement | HTMLTextAreaElement>, newValue?: string) {\r\n        if (newValue)\r\n            this.setState({ ...this.state, EndpointUrl: newValue })\r\n    }\r\n    private UpdateRequestBody(event: React.FormEvent<HTMLInputElement | HTMLTextAreaElement>, newValue?: string) {\r\n        if (newValue)\r\n            this.setState({ ...this.state, RequestBody: newValue })\r\n    }\r\n    private UpdateMethod(event: React.FormEvent<HTMLDivElement>, option?: IDropdownOption, index?: number) {\r\n        if (option)\r\n            this.setState({ ...this.state, Method: option.text })\r\n    }\r\n    render() {\r\n        const selectedItem = this.state.Method;\r\n        return <div>\r\n            <TextField label=\"Web relative url\" onChange={this.UpdateWebUrl} value={this.state.WebUrl} />\r\n            <TextField label=\"API Endpoint\" onChange={this.UpdateEndpointUrl} value={this.state.EndpointUrl} />\r\n            <Dropdown\r\n                label=\"Select HTTP Method\"\r\n                placeholder=\"Select method\"\r\n                selectedKey={selectedItem ? selectedItem : \"GET\"}\r\n                onChange={this.UpdateMethod}\r\n                options={[\r\n                    { key: 'GET', text: 'GET' },\r\n                    { key: 'POST', text: 'POST' },\r\n                    { key: 'PATCH', text: 'PATCH' },\r\n                    { key: 'MERGE', text: 'MERGE' },\r\n                    { key: 'DELETE', text: 'DELETE' }\r\n                ]}\r\n                styles={{ dropdown: { width: 300 } }}\r\n            />\r\n            <TextField label=\"Body\" multiline autoAdjustHeight onChange={this.UpdateRequestBody} />\r\n            <PrimaryButton text=\"Send Query\" onClick={this.HandleClick} allowDisabledFocus />\r\n            <TextField label=\"Response\" multiline autoAdjustHeight value={this.state.Response || \"\"} />\r\n        </div>\r\n    }\r\n}","import { IWebClient } from \"./IWebClient\";\r\n\r\ndeclare var chrome:any;\r\n\r\nexport class CurrentTabWebClient implements IWebClient{\r\n    CallWebService<T>(url: string, requestProperties: any): Promise<T> {\r\n        requestProperties.headers = requestProperties.headers || {};\r\n        requestProperties.headers.accept = requestProperties.headers.accept || \"application/json\"\r\n        let requestPropsSerialized: string = JSON.stringify(requestProperties);\r\n        return new Promise<T>((resolve,error)=>{\r\n            chrome.tabs.getSelected(null, (tab:{id:number})=>{\r\n                chrome.tabs.executeScript(tab.id,{\r\n                    code: \"fetch(\\\"\" + url +\"\\\", \" + requestPropsSerialized + \")\" +\r\n                    \".then((result)=>{ return result.json().then(responseText=>{chrome.runtime.sendMessage(responseText)})})\"\r\n                },()=>{\r\n                    new Promise<T>(resolve => {\r\n                    chrome.runtime.onMessage.addListener(function listener(result:T) {\r\n                      chrome.runtime.onMessage.removeListener(listener);\r\n                      resolve(result);\r\n                    });\r\n                  }).then(result => {\r\n                    resolve(result);\r\n                  })\r\n                })\r\n            })\r\n        });\r\n    }\r\n\r\n}","import { IWebClient } from \"./IWebClient\";\r\n\r\ndeclare var chrome:any;\r\n\r\nexport class DevToolsCurrentTabWebClient implements IWebClient{\r\n    CallWebService<T>(url: string, requestProperties: any): Promise<T> {\r\n        requestProperties.headers = requestProperties.headers || {};\r\n        requestProperties.headers.accept = requestProperties.headers.accept || \"application/json\"\r\n        let requestPropsSerialized: string = JSON.stringify(requestProperties);\r\n        return new Promise<T>((resolve,error)=>{\r\n            chrome.devtools.inspectedWindow.eval(\"fetch(\\\"\" + url +\"\\\", \" + requestPropsSerialized + \")\" +\r\n            \".then((result)=>{ return result.json().then(responseText=>{chrome.runtime.sendMessage(responseText)})})\",()=>{\r\n                new Promise<T>(resolve => {\r\n                chrome.runtime.onMessage.addListener(function listener(result:T) {\r\n                  chrome.runtime.onMessage.removeListener(listener);\r\n                  resolve(result);\r\n                });\r\n              }).then(result => {\r\n                resolve(result);\r\n              })\r\n            });\r\n        });\r\n    }\r\n\r\n}","import { IPageContextInfoProvider } from \"./IPageContextInfoProvider\";\r\ndeclare var chrome: any;\r\n\r\nexport class CurrentTabPageContextProvider implements IPageContextInfoProvider {\r\n    GetPageContextInfo(): Promise<any> {\r\n        return new Promise<any>((resolve, error) => {\r\n            chrome.tabs.getSelected(null, (tab: { id: number }) => {\r\n\r\n                // let pageContextInfo: string = \"\";\r\n                // chrome.tabs.executeScript(tab.id, {\r\n                //     code: \"_spPageContextInfo\"\r\n                // },(result:any)=>{\r\n                //     pageContextInfo = result;\r\n                // });\r\n                chrome.tabs.executeScript(tab.id, {\r\n                    code: \"fetch(\\\" + window.location.href + \\\", {headers:{accept: 'application/json'}})\" +\r\n                        \".then((result)=>{ return result.json().then(responseText=>{chrome.runtime.sendMessage(responseText)})})\"\r\n                }, () => {\r\n                    new Promise<any>(resolve => {\r\n                        chrome.runtime.onMessage.addListener(function listener(result: any) {\r\n                            chrome.runtime.onMessage.removeListener(listener);\r\n                            resolve(result);\r\n                        });\r\n                    }).then(result => {\r\n                        resolve(result.spPageContextInfo);\r\n                    })\r\n                })\r\n            });\r\n        });\r\n    }\r\n}\r\n","import { APIClientProps } from \"../APIClient\";\r\nimport React, { Component } from 'react';\r\nimport { TextField } from 'office-ui-fabric-react/lib/TextField';\r\nimport { IPageContextInfoProvider } from \"../Utils/IPageContextInfoProvider\";\r\n\r\nexport class PageContextInfoComponent extends Component<{\r\n    PageContextInfoProvider: IPageContextInfoProvider;\r\n}, {\r\n    Info: any;\r\n}> {\r\n    constructor(props: { PageContextInfoProvider: IPageContextInfoProvider }) {\r\n        super(props);\r\n        props.PageContextInfoProvider.GetPageContextInfo().then((info)=>{\r\n            this.setState({Info: info});\r\n        })\r\n    }\r\n    render() {\r\n        return (\r\n            (this.state &&\r\n            <TextField label=\"Body\" multiline autoAdjustHeight value={this.state.Info} />)\r\n        )\r\n    }\r\n}","import React from 'react';\nimport './App.css';\nimport { APIClient } from './APIClient';\nimport { CurrentTabWebClient } from './Utils/CurrentTabWebClient';\nimport { DevToolsCurrentTabWebClient } from './Utils/DevToolsCurrentTabWebClient';\nimport { CurrentTabPageContextProvider } from './Utils/CurrentTabPageContextProvider';\nimport { PageContextInfoComponent } from './Components/PageContextInfoComponent';\n\ndeclare var chrome: any;\n\nconst App: React.FC = () => {\n  let webClient = chrome.devtools ? new DevToolsCurrentTabWebClient() : new CurrentTabWebClient()\n  let pcProvider = new CurrentTabPageContextProvider();\n  return (\n    <div className=\"App\">\n      <APIClient WebClient={webClient} ></APIClient>\n      <PageContextInfoComponent PageContextInfoProvider={pcProvider} ></PageContextInfoComponent>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}